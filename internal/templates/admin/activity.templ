package templates

import (
	"fmt"
	"github.com/SerhiiCho/timeago/v3"
	"github.com/nathanhollows/Rapua/v6/internal/flash"
	"github.com/nathanhollows/Rapua/v6/internal/services"
	"github.com/nathanhollows/Rapua/v6/models"
	"github.com/uptrace/bun/schema"
	"time"
)

// getTeamStatus calculates the status of a team based on its current state
func getTeamStatus(team models.Team, totalLocations int) services.TeamStatus {
	if team.MustCheckOut != "" {
		return services.StatusOnsite
	} else if len(team.CheckIns) == totalLocations && totalLocations > 0 {
		return services.StatusFinished
	} else if len(team.CheckIns) > 0 {
		return services.StatusTransit
	} else if team.HasStarted {
		return services.StatusStarted
	}
	return services.StatusStarted // Default to "Not Started" behavior
}

// hasMappedLocations checks if any locations have valid coordinates
func hasMappedLocations(locations []models.Location) bool {
	for _, location := range locations {
		if location.Marker.IsMapped() {
			return true
		}
	}
	return false
}

// TeamStatusBadge renders a status badge for a team with optional tooltip and size
templ TeamStatusBadge(status services.TeamStatus, withTooltip bool, size string) {
	switch status {
		case services.StatusOnsite:
			if withTooltip {
				<span class={ fmt.Sprintf("badge badge-accent badge-soft badge-%s tooltip tooltip-left", size) } data-tip="Currently checked in">Onsite</span>
			} else {
				<span class={ fmt.Sprintf("badge badge-accent badge-%s", size) }>Onsite</span>
			}
		case services.StatusFinished:
			if withTooltip {
				<span class={ fmt.Sprintf("badge badge-success badge-soft badge-%s tooltip tooltip-left", size) } data-tip="Finished all locations!">Finished</span>
			} else {
				<span class={ fmt.Sprintf("badge badge-success badge-%s", size) }>Finished</span>
			}
		case services.StatusTransit:
			if withTooltip {
				<span class={ fmt.Sprintf("badge badge-secondary badge-soft badge-%s tooltip tooltip-left", size) } data-tip="This team is between locations">In transit</span>
			} else {
				<span class={ fmt.Sprintf("badge badge-secondary badge-%s", size) }>In transit</span>
			}
		case services.StatusStarted:
			if withTooltip {
				<span class={ fmt.Sprintf("badge badge-ghost badge-%s tooltip tooltip-left", size) } data-tip="This team has not checked in anywhere yet">Started</span>
			} else {
				<span class={ fmt.Sprintf("badge badge-ghost badge-%s", size) }>Started</span>
			}
		default:
			<span class={ fmt.Sprintf("badge badge-ghost badge-%s", size) }>Not Started</span>
	}
}

templ ActivityTracker(instance models.Instance) {
	<div class="flex flex-col sm:flex-row gap-3 justify-between items-center w-full p-5">
		<h1 class="text-2xl font-bold">
			Activity
		</h1>
		@ActivityStatusBadge(instance)
		<div class="flex gap-3">
			@GameScheduleStatus(instance)
			<button
				class="btn btn-secondary tooltip"
				data-tip="Send an announcement to all teams"
				onclick="announcement_modal.showModal()"
			>
				<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-megaphone"><path d="m3 11 18-5v12L3 14v-3z"></path><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"></path></svg>
				Announce
			</button>
			<button
				hx-get="/admin/facilitator/create-link"
				hx-target="#facilitator_link_modal"
				hx-swap="innerHTML"
				class="btn btn-circle tooltip tooltip-left md:tooltip-top"
				data-tip="Share activity overview with Facilitators"
				_="on click facilitator_link_modal.showModal()"
			>
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share-2 w-4 h-4 mx-auto"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"></line><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"></line></svg>
			</button>
			<dialog id="facilitator_link_modal" class="modal modal-bottom sm:modal-middle">
				@FacilitatorLinkModal()
			</dialog>
		</div>
	</div>
	<div class="relative flex flex-col md:flex-row px-5 md:space-x-5">
		if hasMappedLocations(instance.Locations) {
			<div class="w-full md:w-5/12">
				<div id="map-container" class="group relative w-full aspect-square lg:w-96 rounded-lg shadow-lg my-5 overflow-hidden">
					<div id="map-activity" class="map w-full h-full rounded-lg"></div>
				</div>
				<div class="join join-vertical w-full">
					for _,location := range instance.Locations {
						<input
							type="hidden"
							class="location-name"
							if location.Marker.IsMapped() {
								data-lat={ fmt.Sprint(location.Marker.Lat) }
								data-lng={ fmt.Sprint(location.Marker.Lng) }
							}
							value={ location.Marker.Name }
						/>
					}
				</div>
			</div>
		}
		<div class={ "overflow-y-auto w-full", templ.KV("mx-auto max-w-6xl", !hasMappedLocations(instance.Locations)) }>
			<div class="overflow-x-auto">
				<table
					id="team-activity"
					class="overflow-hidden table table-sm md:table-md table-zebra w-full mt-5 md:mt-0 h-auto self-start"
					hx-get="/admin/activity/teams"
					hx-target="#team-activity"
					hx-swap="outerHTML"
					hx-trigger="load"
				></table>
			</div>
		</div>
	</div>
	@scheduleModal(instance)
	@announcementModal()
	@teamModal()
	if hasMappedLocations(instance.Locations) {
		<script>
(function () {
  let map; // Store the map instance globally within the IIFE
  let markerArray = []; // Store the markers array globally within the IIFE

  function initializeMap() {
    const locations = document.querySelectorAll('.location-name');
    // Calculate the center and zoom level based on the locations
    let coords = [170.5111643, -45.8650509];
    let zoom = 17;
    for (let i = 0; i < locations.length; i++) {
      if (!locations[i].dataset.lat || !locations[i].dataset.lng) {
        continue;
      }
      const lat = parseFloat(locations[i].dataset.lat);
      const lng = parseFloat(locations[i].dataset.lng);
      if (!isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0) {
        coords = [lng, lat];
        break;
      }
    }

    // Clear any existing markers
    markerArray.forEach(marker => marker.remove());
    markerArray = [];

    // Destroy existing map instance if it exists
    if (map) {
      map.remove();
      map = null; // Explicitly set to null to clear reference
    }

    // Set the Mapbox access token
    mapboxgl.accessToken = document.getElementById('mapbox_key').dataset.key;

    // Determine the style based on color scheme
    const style = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
      ? 'mapbox://styles/nathanhollows/cl9w3nxff002m14sy9fco4vnr'
      : 'mapbox://styles/nathanhollows/clszboe2y005i01oid8ca37jm';

    // Create the map
    map = new mapboxgl.Map({
      container: 'map-activity',
      style: style,
      center: coords,
      zoom: zoom,
      cooperativeGestures: true,
    });

    map.on('load', function () {
      map.resize();
    });

    // Find and loop through .location-name elements to create markers with original numbers
    locations.forEach(function (location, index) {
	  if (!location.dataset.lat || !location.dataset.lng) {
		return;
		}
      // Create a HTML element for each marker
      const el = document.createElement('div');
      el.className = 'marker';
      el.innerHTML = '<span><b>' + (index + 1) + '</b></span>';

      // Create the marker
      const marker = new mapboxgl.Marker(el)
        .setLngLat([location.dataset.lng, location.dataset.lat])
        .setPopup(new mapboxgl.Popup({ offset: 25, focusAfterOpen: false }) // Add popups
          .setHTML('<h3>' + location.value + '</h3>'));

				marker.getElement().addEventListener('mouseenter', function () {
				  popup = marker.getPopup();
					if (!popup.isOpen()) {
						marker.togglePopup();
					}
				});

				marker.getElement().addEventListener('mouseleave', function () {
					marker.togglePopup();	
				});

      markerArray.push(marker);

			let locationContainer = location.parentElement.parentElement;

    });

    // Sort markers by latitude
    markerArray.sort(function (a, b) {
      return parseFloat(b.getLngLat().lat) - parseFloat(a.getLngLat().lat);
    });

    // Add markers to the map in the sorted order without changing their displayed numbers
    markerArray.forEach(marker => {
      marker.addTo(map);
    });

    // Fit the map to the bounds of the markers
    if (markerArray.length > 1) {
      const bounds = new mapboxgl.LngLatBounds();
      markerArray.forEach(marker => {
        bounds.extend(marker.getLngLat());
      });

      map.fitBounds(bounds, { padding: 50 });
    }

    MapboxStyleSwitcher.extend(map, {
      // Optional: Override default options
      controlPosition: 'top-left', // Position on the map
      // satelliteStyle: 'custom-satellite-style-if-needed'
    }, markerArray);
  }

  // Initialize the map on page load
  initializeMap();

})();
</script>
	}
}

templ teamModal() {
	<dialog id="team_modal" class="modal modal-bottom sm:modal-middle">
		<div class="modal-box">
			<!-- Contents will be replaced by the fetched content -->
		</div>
	</dialog>
	<script>
	document.getElementById("team_modal").addEventListener('htmx:afterSwap', (evt) => {
	  // Open the modal once the content is loaded and swapped
	  document.getElementById("team_modal").showModal();
	});
	</script>
}

templ ActivityTeamsTable(settings models.InstanceSettings, locationCount int, leaderboardData []services.LeaderBoardTeamData, currentSortField string, currentSortOrder string) {
	<div class="overflow-x-auto">
		<table
			id="team-activity"
			class="overflow-hidden table table-sm md:table-md table-zebra w-full mt-5 md:mt-0 h-auto self-start"
			hx-get={ fmt.Sprintf("/admin/activity/teams?sort=%s&order=%s", currentSortField, currentSortOrder) }
			hx-target="#team-activity"
			hx-swap="outerHTML"
			hx-trigger="every 30s"
		>
			<!-- head -->
			<thead class="uppercase text-xs font-normal tracking-wider">
				<tr>
					<th class="text-center">
						@sortableHeader("rank", "Rank", currentSortField, currentSortOrder, true)
					</th>
					<th>
						@sortableHeader("code", "Code", currentSortField, currentSortOrder, false)
					</th>
					<th>
						@sortableHeader("name", "Name", currentSortField, currentSortOrder, false)
					</th>
					if settings.EnablePoints {
						<th>
							@sortableHeader("points", "Points", currentSortField, currentSortOrder, false)
						</th>
					}
					<th>
						@sortableHeader("last_seen", "Last Seen", currentSortField, currentSortOrder, false)
					</th>
					<th>
						@sortableHeader("progress", "Progress", currentSortField, currentSortOrder, false)
					</th>
					<th>
						@sortableHeader("status", "Status", currentSortField, currentSortOrder, false)
					</th>
				</tr>
			</thead>
			<tbody
				id="contents"
				class="overflow-x-hidden"
				hx-disinherit="*"
			>
				for _, teamData := range leaderboardData {
					<tr
						class="hover:bg-base-300 hover:scale-[1.01] transition-all overflow-hidden cursor-pointer"
						hx-get={ templ.URL(fmt.Sprintf("/admin/teams/%s", teamData.Code)) }
						hx-target="body"
						hx-swap="outerHTML"
						hx-push-url="true"
					>
						<td class="text-center">
							switch teamData.Rank {
								case 1:
									<span class="text-2xl">ðŸ¥‡</span>
								case 2:
									<span class="text-2xl">ðŸ¥ˆ</span>
								case 3:
									<span class="text-2xl">ðŸ¥‰</span>
								default:
									<span class="text-xl">{ fmt.Sprint(teamData.Rank) }</span>
							}
						</td>
						<td class="font-mono tracking-wider">
							{ teamData.Code }
						</td>
						if teamData.Name != "" {
							<td>{ teamData.Name }</td>
						} else {
							<td><em class="opacity-50">No name set</em></td>
						}
						if settings.EnablePoints {
							<td>{ fmt.Sprint(teamData.Points) }</td>
						}
						<td>
							<span class="tooltip" data-tip={ teamData.LastSeen.Local().Format("02 Jan 03:04 PM") }>
								{ timeago.Parse(teamData.LastSeen) }
							</span>
						</td>
						<td>
							if locationCount > 0 {
								{ fmt.Sprintf("%d âˆ• %d", teamData.Progress, locationCount) }
							} else {
								<em class="opacity-50">No locations</em>
							}
						</td>
						<td>
							@TeamStatusBadge(teamData.Status, true, "sm")
						</td>
					</tr>
				}
				if len(leaderboardData) == 0 {
					<tr>
						<td colspan="7" class="text-center py-5">
							No teams or players have joined the game yet.
						</td>
					</tr>
				}
			</tbody>
		</table>
	</div>
}

templ ActivityStatusBadge(instance models.Instance) {
	<div id="activity-status-badge" class="md:mr-auto inline-grid grid-cols-2 items-center w-min gap-5">
		<div class="inline-grid *:[grid-area:1/1]">
			switch instance.GetStatus() {
				case models.Active:
					<div class="status status-lg status-success animate-ping"></div>
					<div class="status status-lg status-success"></div>
				case models.Scheduled:
					<div class="status status-lg status-info"></div>
				case models.Closed:
					<div class="status status-lg"></div>
			}
		</div>
		{ instance.GetStatus().String() }
	</div>
}

templ ActivityStatusBadgeOOB(instance models.Instance) {
	<div id="activity-status-badge" hx-swap-oob="true" class="md:mr-auto inline-grid grid-cols-2 items-center w-min gap-5">
		<div class="inline-grid *:[grid-area:1/1]">
			switch instance.GetStatus() {
				case models.Active:
					<div class="status status-lg status-success animate-ping"></div>
					<div class="status status-lg status-success"></div>
				case models.Scheduled:
					<div class="status status-lg status-info"></div>
				case models.Closed:
					<div class="status status-lg"></div>
			}
		</div>
		{ instance.GetStatus().String() }
	</div>
}

templ GameScheduleStatus(instance models.Instance, messages ...flash.Message) {
	for _, msg := range messages {
		@Toast(msg)
	}
	<div id="schedule-status" class="flex flex-row gap-3">
		switch instance.GetStatus() {
			case models.Active:
				<a
					hx-get="/admin/schedule/stop"
					hx-target="#schedule-status"
					class="btn btn-error flex join-item tooltip"
					data-tip="Stop the game"
				>
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-octagon-x w-5 h-5"><path d="m15 9-6 6"></path><path d="M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z"></path><path d="m9 9 6 6"></path></svg>
					Stop
				</a>
				@scheduleButton(instance.EndTime.After(instance.StartTime.Time), instance.EndTime)
			case models.Scheduled:
				<a
					hx-get="/admin/schedule/start"
					hx-target="#schedule-status"
					class="btn btn-primary flex join-item tooltip"
					data-tip="Start the game early"
				>
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play w-5 h-5"><polygon points="6 3 20 12 6 21 6 3"></polygon></svg>
					Start now
				</a>
				@scheduleButton(true, instance.StartTime)
			case models.Closed:
				<a hx-get="/admin/schedule/start" hx-target="#schedule-status" class="btn btn-primary flex join-item tooltip" data-tip="Start the game">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play w-5 h-5"><polygon points="6 3 20 12 6 21 6 3"></polygon></svg>
					Start
				</a>
				@scheduleButton(false, instance.StartTime)
		}
	</div>
}

templ scheduleButton(scheduled bool, t schema.NullTime) {
	if !scheduled {
		<button class="btn btn-secondary flex join-item tooltip" onclick="schedule_modal.showModal()" data-tip="Set the start and end time">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calendar-clock w-5 h-5"><path d="M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5"></path><path d="M16 2v4"></path><path d="M8 2v4"></path><path d="M3 10h5"></path><path d="M17.5 17.5 16 16.3V14"></path><circle cx="16" cy="16" r="6"></circle></svg>
			Schedule
		</button>
	} else {
		<button
			id="start-time"
			data-start={ t.Format("02-Jan-2006 15:04:05") }
			class="btn btn-secondary flex join-item tooltip"
			onclick="schedule_modal.showModal()"
			data-tip="Sechedule"
		>
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calendar-clock w-5 h-5"><path d="M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5"></path><path d="M16 2v4"></path><path d="M8 2v4"></path><path d="M3 10h5"></path><path d="M17.5 17.5 16 16.3V14"></path><circle cx="16" cy="16" r="6"></circle></svg>
			if int(t.Time.Sub(time.Now()).Seconds()) / 86400 > 0 {
				<div id="days-container" class="leading-none flex align-middle">
					<span class="countdown font-bold leading-none" id="days" style={ fmt.Sprintf("--value: %d", int(t.Time.Sub(time.Now()).Seconds())/86400) }>
						<span></span>
					</span>
					d
				</div>
			} else {
				<div id="days-container" class="leading-none flex align-middle" style="display: none">
					<span class="countdown font-bold leading-none" id="days" style="--value: 0">
						<span></span>
					</span>
					d
				</div>
			}
			if (int(t.Time.Sub(time.Now()).Seconds()) % 86400) / 3600 > 0 {
				<div id="hours-container" class="leading-none flex align-middle">
					<span class="countdown font-bold leading-none" id="hours" style={ fmt.Sprintf("--value: %d", (int(t.Time.Sub(time.Now()).Seconds())%86400)/3600) }>
						<span></span>
					</span>
					h
				</div>
			} else {
				<div id="hours-container" class="leading-none flex align-middle" style="display: none">
					<span class="countdown font-bold leading-none" id="hours" style="--value: 0">
						<span></span>
					</span>
					h
				</div>
			}
			<div class="leading-none flex align-middle">
				<span class="countdown font-bold" id="minutes" style={ fmt.Sprintf("--value: %d", (int(t.Time.Sub(time.Now()).Seconds())%3600)/60) }>
					<span></span>
				</span>
				m
			</div>
			<div class="leading-none flex align-middle">
				<span class="countdown font-bold" id="seconds" style={ fmt.Sprintf("--value: %d", int(t.Time.Sub(time.Now()).Seconds())%60) }>
					<span></span>
				</span>
				s
			</div>
		</button>
		<style>
				for i := range 60 {
					{ fmt.Sprintf("[data-value=\"%d\"]", i) } {
						--value: { fmt.Sprint(i) };
				    }
				}
				</style>
		<script>
  // JavaScript for countdown
  (function() {
    // Store interval ID on window object to persist across HTMX swaps
    if (!window.gameCountdownInterval) {
      window.gameCountdownInterval = null;
    }

    function startCountdown(startTime) {
      // Clear any existing interval before starting a new one
      if (window.gameCountdownInterval) {
        clearInterval(window.gameCountdownInterval);
        window.gameCountdownInterval = null;
      }

      function updateCountdown() {
        const now = new Date();
        const remainingTime = new Date(startTime) - now;

        if (remainingTime == 0) {
          window.location.reload();
          return;
        }

        const seconds = Math.floor((remainingTime / 1000) % 60);
        const minutes = Math.floor((remainingTime / 1000 / 60) % 60);
        const hours = Math.floor((remainingTime / 1000 / 60 / 60) % 24);
        const days = Math.floor(remainingTime / 1000 / 60 / 60 / 24);

        const secondsEl = document.getElementById("seconds");
        const minutesEl = document.getElementById("minutes");
        const hoursContainer = document.getElementById("hours-container");
        const hoursEl = document.getElementById("hours");
        const daysContainer = document.getElementById("days-container");
        const daysEl = document.getElementById("days");

        if (!secondsEl || !minutesEl) return; // Elements removed, stop updating

        secondsEl.style.setProperty('--value', seconds);
        minutesEl.style.setProperty('--value', minutes);

        if (hours > 0) {
          hoursContainer.style.display = "flex";
          hoursEl.style.setProperty('--value', hours);
        } else {
          hoursContainer.style.display = "none";
        }

        if (days > 0) {
          daysContainer.style.display = "flex";
          daysEl.style.setProperty('--value', days);
        } else {
          daysContainer.style.display = "none";
        }
      }

      updateCountdown();
      window.gameCountdownInterval = setInterval(updateCountdown, 1000);
    }

    if (document.getElementById('start-time') != null) {
      function UTCtoLocal(time) {
        const utc = new Date(`${time}`);
        const local = new Date(utc.getTime() - utc.getTimezoneOffset() * 60000);
        return local
      }
      const startTimeElement = document.getElementById('start-time');
      const startTime = startTimeElement.dataset.start;
      startCountdown(UTCtoLocal(startTime));
    }
  })();
</script>
	}
}

templ TeamActivity(settings models.InstanceSettings, team models.Team, notifications []models.Notification, nextLocations []models.Location) {
	<h3 class="text-lg font-bold">
		{ team.Code }
		if team.Name != "" {
			<span class="opacity-50">âˆ•</span> { team.Name }
		}
		if settings.EnablePoints {
			<span class="badge badge-info badge-sm">{ fmt.Sprint(team.Points) } pts</span>
		}
	</h3>
	<!-- Current Location -->
	if team.MustCheckOut != "" {
		<div class="w-full">
			<p class="py-3 font-bold divider divider-start">Current Location</p>
			{ team.BlockingLocation.Name }
		</div>
	}
	<!-- Next Locations -->
	<div class="w-full">
		<p class="py-3 font-bold divider divider-start">Next Locations</p>
		if len(nextLocations) > 0 {
			<div class="prose">
				<ul>
					for _, location := range nextLocations {
						<li>
							{ location.Name }
						</li>
					}
				</ul>
			</div>
		} else {
			<p>All done!</p>
		}
	</div>
	<!-- Previous Locations -->
	if len(team.CheckIns) > 0 {
		<div class="py-3 font-bold divider divider-start">
			Previous Locations
		</div>
		for _, scan := range team.CheckIns {
			if !scan.MustCheckOut {
				<div class="prose">
					<ul>
						<li>
							{ scan.Location.Name }
							<span class="convert-time badge badge-sm badge-ghost" data-datetime={ fmt.Sprint(scan.CreatedAt.UTC()) }></span>
							if settings.EnablePoints && scan.Points > 0 {
								<span class="badge badge-sm badge-info">+{ fmt.Sprint(scan.Points) } pts</span>
							}
						</li>
					</ul>
				</div>
			}
		}
	}
	<p class="py-3 font-bold divider divider-start">
		Alerts
	</p>
	if len(notifications) > 0 {
		for _, notification := range notifications {
			<div class="chat chat-start">
				<div class="chat-bubble">{ notification.Content }</div>
				<div class="chat-footer text-xs opacity-50 flex items-center gap-2">
					if notification.Dismissed {
						Read
					} else {
						Unread
					}
					Â·
					<time>{ fmt.Sprint("Sent ", notification.CreatedAt.Local().Format("02 Jan 03:04 PM")) }</time>
				</div>
			</div>
		}
	}
	<label class="form-control w-full mt-3">
		<form hx-post="/admin/notify/team/" hx-swap="none">
			<input type="hidden" name="teamCode" value={ team.Code }/>
			<div class="join w-full">
				<input class="input join-item w-full" name="content" placeholder="Message" autocomplete="off" autofocus="off" required/>
				<button type="submit" class="btn btn-primary join-item rounded-r-full" onclick="announcement_modal.close()">
					Send
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal w-5 h-5"><path d="m3 3 3 9-3 9 19-9Z"></path><path d="M6 12h16"></path></svg>
				</button>
			</div>
		</form>
		<div class="label">
			<span class="label-text-alt">This is a read-only message. Teams cannot reply.</span>
		</div>
	</label>
	<div class="modal-action">
		<form method="dialog">
			<!-- if there is a button in form, it will close the modal -->
			<button class="btn">Close</button>
		</form>
	</div>
	<form method="dialog">
		<button
			class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
		>âœ•</button>
	</form>
}

templ scheduleModal(instance models.Instance) {
	<dialog id="schedule_modal" class="modal modal-bottom sm:modal-middle">
		<div class="modal-box">
			<h3 class="text-lg font-bold">Schedule a Game</h3>
			<p class="py-3">
				Schedule a game to start and/or end at a specific time. 
			</p>
			<form hx-post="/admin/schedule/" hx-target="#schedule-status" hx-swap="outerHTML">
				<div class="divider py-5">
					<div class="form-control">
						<label class="label cursor-pointer flex gap-3">
							Scheduled Start
							if instance.StartTime.Time.IsZero() {
								<input type="checkbox" name="set_start" class="checkbox"/>
							} else {
								<input type="checkbox" name="set_start" class="checkbox" checked/>
							}
						</label>
					</div>
				</div>
				<div id="utc-start-time" class="join flex justify-center pb-5" data-start={ instance.StartTime.Format("2006-01-02 15:04") }>
					<input
						id="start_date"
						type="date"
						name="start_date"
						class="input join-item"
					/>
					<input
						id="start_time"
						type="time"
						name="start_time"
						class="input join-item"
					/>
				</div>
				<div class="divider py-5">
					<div class="form-control">
						<label class="label cursor-pointer flex gap-3">
							Scheduled End
							if !instance.EndTime.IsZero() && instance.EndTime.After(instance.StartTime.Time) {
								<input type="checkbox" name="set_end" class="checkbox" checked/>
							} else {
								<input type="checkbox" name="set_end" class="checkbox"/>
							}
						</label>
					</div>
				</div>
				<div id="utc-end-time" class="join flex justify-center" data-end={ instance.EndTime.Format("2006-01-02 15:04") }>
					<input
						id="end_date"
						type="date"
						name="end_date"
						class="input join-item"
					/>
					<input
						id="end_time"
						type="time"
						name="end_time"
						class="input join-item"
					/>
				</div>
				<!-- Hidden UTC Inputs -->
				<input type="hidden" name="utc_start_date"/>
				<input type="hidden" name="utc_start_time"/>
				<input type="hidden" name="utc_end_date"/>
				<input type="hidden" name="utc_end_time"/>
				<div class="modal-action">
					<button class="btn" onclick="event.preventDefault(); schedule_modal.close()">Nevermind</button>
					<button type="submit" onclick="schedule_modal.close()" class="btn btn-primary">Save</button>
				</div>
			</form>
			<form method="dialog">
				<button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button>
			</form>
		</div>
	</dialog>
	<script>
		function localToUTC(date, time) {
			const utc = new Date(`${date}T${time}`);
			return {
				date: utc.toISOString().split('T')[0],
				time: utc.toISOString().split('T')[1].substring(0, 5)  // Get HH:MM format
			};
		}

		function UTCtoLocal(date, time) {
			const utc = new Date(`${date}T${time}Z`);
			const local = new Date(utc.getTime() - utc.getTimezoneOffset() * 60000);
			return {
				date: local.toISOString().split('T')[0],
				time: local.toISOString().split('T')[1].substring(0, 5)  // Get HH:MM format
			};
		}

		function populateDateTimeInputs() {
			const startDateInput = document.querySelector('input[name="start_date"]');
			const startTimeInput = document.querySelector('input[name="start_time"]');
			const endDateInput = document.querySelector('input[name="end_date"]');
			const endTimeInput = document.querySelector('input[name="end_time"]');

			const utcStartElement = document.getElementById('utc-start-time');
			const utcEndElement = document.getElementById('utc-end-time');

			const utcStart = utcStartElement.dataset.start.split(' ');
			const utcEnd = utcEndElement.dataset.end.split(' ');

			// Check the time is not empty: 0001-01-01 00:00
			if (utcStart[0] != '0001-01-01') {
				const localStart = UTCtoLocal(utcStart[0], utcStart[1]);
				startDateInput.value = localStart.date;
				startTimeInput.value = localStart.time;
			}

			if (utcEnd[0] != '0001-01-01') {
				const localEnd = UTCtoLocal(utcEnd[0], utcEnd[1]);
				endDateInput.value = localEnd.date;
				endTimeInput.value = localEnd.time;
			}
		}

        function handleDateTimeChange() {
            const startDateInput = document.querySelector('input[name="start_date"]');
            const startTimeInput = document.querySelector('input[name="start_time"]');
            const endDateInput = document.querySelector('input[name="end_date"]');
            const endTimeInput = document.querySelector('input[name="end_time"]');
            const setStartCheckbox = document.querySelector('input[name="set_start"]');
            const setEndCheckbox = document.querySelector('input[name="set_end"]');

            // Only convert if checkbox is checked AND both date and time have values
            if (setStartCheckbox.checked && startDateInput.value && startTimeInput.value) {
                const utcStart = localToUTC(startDateInput.value, startTimeInput.value);
                document.querySelector('input[name="utc_start_date"]').value = utcStart.date;
                document.querySelector('input[name="utc_start_time"]').value = utcStart.time;
            } else {
                document.querySelector('input[name="utc_start_date"]').value = '';
                document.querySelector('input[name="utc_start_time"]').value = '';
            }

            if (setEndCheckbox.checked && endDateInput.value && endTimeInput.value) {
                const utcEnd = localToUTC(endDateInput.value, endTimeInput.value);
                document.querySelector('input[name="utc_end_date"]').value = utcEnd.date;
                document.querySelector('input[name="utc_end_time"]').value = utcEnd.time;
            } else {
                document.querySelector('input[name="utc_end_date"]').value = '';
                document.querySelector('input[name="utc_end_time"]').value = '';
            }
        }

		function initScheduleModal() {
			populateDateTimeInputs();
			handleDateTimeChange();
		}

		// Set up event listeners once when the script loads
		(function() {
            const inputs = document.querySelectorAll('#schedule_modal input[type="date"], #schedule_modal input[type="time"]');
            const checkboxes = document.querySelectorAll('#schedule_modal input[type="checkbox"]');
            const form = document.querySelector('#schedule_modal form');
			const modal = document.getElementById('schedule_modal');

            inputs.forEach(input => {
                input.addEventListener('change', handleDateTimeChange);
            });

            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', handleDateTimeChange);
            });

            // Ensure UTC conversion happens on form submission
            form.addEventListener('submit', function(e) {
                handleDateTimeChange();
            });

			// Initialize whenever the modal is opened
			const observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(mutation) {
					if (mutation.type === 'attributes' && mutation.attributeName === 'open') {
						if (modal.hasAttribute('open')) {
							initScheduleModal();
						}
					}
				});
			});

			if (modal) {
				observer.observe(modal, { attributes: true });
			}
		})();
    </script>
}

templ announcementModal() {
	<dialog id="announcement_modal" class="modal modal-bottom sm:modal-middle">
		<div class="modal-box">
			<h3 class="text-lg font-bold">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-megaphone inline-block w-5 h-5 mb-1 mr-2"><path d="m3 11 18-5v12L3 14v-3z"></path><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"></path></svg>
				Announcement
			</h3>
			<p class="py-3">Send an announcement to all teams.</p>
			<form hx-post="/admin/notify/all" hx-swap="none">
				<textarea class="textarea w-full" name="content" placeholder="Announcement"></textarea>
				<p class="text-sm py-3"><em>Note:</em> This will only be sent to teams that have already started playing.</p>
				<div class="modal-action">
					<button class="btn" onclick="event.preventDefault(); announcement_modal.close()">Nevermind</button>
					<button class="btn btn-primary" onclick="announcement_modal.close()">Send</button>
				</div>
			</form>
			<form method="dialog">
				<button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button>
			</form>
		</div>
	</dialog>
}

templ sortableHeader(field string, label string, currentSortField string, currentSortOrder string, center bool) {
	<span
		class={ "cursor-pointer inline-flex gap-1 items-center hover:text-primary transition-colors", templ.KV("justify-center", center) }
		hx-get={ getSortURL(field, currentSortField, currentSortOrder) }
		hx-target="#team-activity"
		hx-swap="outerHTML"
		title={ getSortTooltip(field, currentSortField, currentSortOrder) }
	>
		{ label }
		if currentSortField == field {
			if currentSortOrder == "desc" {
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down-icon lucide-arrow-down w-4 h-4"><path d="M12 5v14"></path><path d="m19 12-7 7-7-7"></path></svg>
			} else {
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up-icon lucide-arrow-up w-4 h-4"><path d="m5 12 7-7 7 7"></path><path d="M12 19V5"></path></svg>
			}
		} else {
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up-down w-4 h-4 opacity-40"><path d="m21 16-4 4-4-4"></path><path d="M17 20V4"></path><path d="m3 8 4-4 4 4"></path><path d="M7 4v16"></path></svg>
		}
	</span>
}

func getSortURL(field string, currentSortField string, currentSortOrder string) string {
	var newOrder string
	if currentSortField == field {
		// Reverse the order if clicking the same field
		if currentSortOrder == "desc" {
			newOrder = "asc"
		} else {
			newOrder = "desc"
		}
	} else {
		// Default order for new field - most fields default to descending except name/code
		if field == "name" || field == "code" {
			newOrder = "asc"
		} else {
			newOrder = "desc"
		}
	}
	return fmt.Sprintf("/admin/activity/teams?sort=%s&order=%s", field, newOrder)
}

func getSortTooltip(field string, currentSortField string, currentSortOrder string) string {
	if currentSortField == field {
		if currentSortOrder == "desc" {
			return fmt.Sprintf("Click to sort %s ascending", field)
		} else {
			return fmt.Sprintf("Click to sort %s descending", field)
		}
	} else {
		if field == "name" || field == "code" {
			return fmt.Sprintf("Click to sort by %s (ascending)", field)
		} else {
			return fmt.Sprintf("Click to sort by %s (descending)", field)
		}
	}
}
